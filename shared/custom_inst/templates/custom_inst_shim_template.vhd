--------------------------------------------------------------------------------
-- File: {{ app_name }}_custom_inst_shim.vhd
-- Generated: {{ timestamp }}
-- Generator: tools/generate_custom_inst.py
--
-- ⚠️  GENERATED FILE - DO NOT EDIT MANUALLY ⚠️
-- This file is automatically generated from the CustomInstApp model.
-- To modify, update {{ app_name }}_app.yaml and regenerate.
--
-- Description:
--   Register mapping shim for {{ app_name }} CustomInstApp.
--   Maps raw Control Registers (CR6-CR15) to friendly signal names
--   and instantiates the application main entity.
--
-- Layer 2 of 3-Layer CustomInstApp Architecture:
--   Layer 1: MCC_TOP_custom_inst_loader.vhd (static, shared)
--   Layer 2: {{ app_name }}_custom_inst_shim.vhd (THIS FILE - generated)
--   Layer 3: {{ app_name }}_custom_inst_main.vhd (hand-written app logic)
--
-- Register Mapping:
{% for reg in registers %}
--   CR{{ reg.cr_number }}: {{ reg.original_name }} → {{ reg.friendly_name }} : {{ reg.vhdl_type }}
{% endfor %}
--
-- References:
--   - docs/CUSTOM_INSTRUMENT_MIGRATION_PLAN.md
--   - {{ app_name }}_app.yaml
--------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library WORK;
use WORK.custom_inst_common_pkg.all;

entity {{ app_name }}_custom_inst_shim is
    port (
        ------------------------------------------------------------------------
        -- Clock and Reset
        ------------------------------------------------------------------------
        Clk         : in  std_logic;
        Reset       : in  std_logic;  -- Active-high reset

        ------------------------------------------------------------------------
        -- VOLO Control Signals (from MCC_TOP_custom_inst_loader)
        ------------------------------------------------------------------------
        volo_ready  : in  std_logic;  -- CR0[31] - Set by loader
        user_enable : in  std_logic;  -- CR0[30] - User control
        clk_enable  : in  std_logic;  -- CR0[29] - Clock gating
        loader_done : in  std_logic;  -- BRAM loader FSM done signal

        ------------------------------------------------------------------------
        -- Handshaking Protocol
        -- Main application controls when register updates are safe
        ------------------------------------------------------------------------
        ready_for_updates : in  std_logic;  -- From main application

        ------------------------------------------------------------------------
        -- Application Registers (from MCC_TOP_custom_inst_loader)
        -- Raw Control Registers CR6-CR15 (max 10 registers)
        ------------------------------------------------------------------------
{% for cr_num in cr_numbers_used %}
        app_reg_{{ cr_num }} : in  std_logic_vector(31 downto 0);
{% endfor %}

        ------------------------------------------------------------------------
        -- BRAM Interface (from custom_inst_bram_loader FSM)
        ------------------------------------------------------------------------
        bram_addr   : in  std_logic_vector(11 downto 0);  -- 4KB address space
        bram_data   : in  std_logic_vector(31 downto 0);  -- 32-bit data
        bram_we     : in  std_logic;                      -- Write enable

        ------------------------------------------------------------------------
        -- MCC I/O (from SimpleCustomInstrument)
        -- Native MCC types: signed(15 downto 0) for all ADC/DAC channels
        ------------------------------------------------------------------------
        InputA      : in  signed(15 downto 0);
        InputB      : in  signed(15 downto 0){% if num_inputs >= 3 %};
        InputC      : in  signed(15 downto 0){% endif %}{% if num_inputs >= 4 %};
        InputD      : in  signed(15 downto 0){% endif %};
        OutputA     : out signed(15 downto 0);
        OutputB     : out signed(15 downto 0){% if num_outputs >= 3 %};
        OutputC     : out signed(15 downto 0){% endif %}{% if num_outputs >= 4 %};
        OutputD     : out signed(15 downto 0){% endif %}
    );
end entity {{ app_name }}_custom_inst_shim;

architecture rtl of {{ app_name }}_custom_inst_shim is

    ----------------------------------------------------------------------------
    -- Friendly Signal Declarations (MCC-Agnostic Interface)
    ----------------------------------------------------------------------------
{% for reg in registers %}
    signal {{ reg.friendly_name }} : {{ reg.vhdl_type }};  -- {{ reg.description }}
{% endfor %}

    ----------------------------------------------------------------------------
    -- Global Enable Signal
    -- Combines all VOLO_READY control bits for safe operation
    ----------------------------------------------------------------------------
    signal global_enable : std_logic;

begin

    ----------------------------------------------------------------------------
    -- Global Enable Computation
    --
    -- All 4 conditions must be met for app to operate:
    --   1. volo_ready  = 1  (loader has deployed bitstream)
    --   2. user_enable = 1  (user has enabled module)
    --   3. clk_enable  = 1  (clock gating enabled)
    --   4. loader_done = 1  (BRAM loading complete)
    ----------------------------------------------------------------------------
    global_enable <= combine_volo_ready(volo_ready, user_enable, clk_enable, loader_done);

    ----------------------------------------------------------------------------
    -- Atomic Register Update Process
    --
    -- Implements gated latching controlled by ready_for_updates signal.
    -- When ready_for_updates='0', shim holds previous values (gate closed).
    -- When ready_for_updates='1', shim latches current CR values atomically.
    --
    -- Reference: HandShakeProtocol.md v2.0 (lines 106-122)
    ----------------------------------------------------------------------------
    REGISTER_UPDATE_PROC: process(Clk)
    begin
        if rising_edge(Clk) then
            if Reset = '1' then
                -- Load default values from YAML specification
                -- These ensure safe startup state before network writes
                -- TODO Phase 4C: Replace type-based defaults with YAML default_value field
{% for reg in registers %}
    {% if reg.reg_type == 'BUTTON' %}
                {{ reg.friendly_name }} <= '0';  -- {{ reg.original_name }} (BUTTON default)
    {% else %}
                {{ reg.friendly_name }} <= (others => '0');  -- {{ reg.original_name }} ({{ reg.reg_type }} default)
    {% endif %}
{% endfor %}
            elsif ready_for_updates = '1' then
                -- Atomic update: Latch all registers together in same cycle
                -- Main application has signaled it's safe to apply changes
{% for reg in registers %}
                {{ reg.friendly_name }} <= app_reg_{{ reg.cr_number }}{{ reg.bit_range }};  -- {{ reg.original_name }}
{% endfor %}
            end if;
            -- else: Hold previous values (gate closed, main app is busy)
        end if;
    end process REGISTER_UPDATE_PROC;

    ----------------------------------------------------------------------------
    -- Instantiate Application Main Entity
    --
    -- MCC-agnostic interface using friendly signal names only
    ----------------------------------------------------------------------------
    APP_MAIN_INST: entity WORK.{{ app_name }}_custom_inst_main
        port map (
            -- Standard Control Signals
            Clk     => Clk,
            Reset   => Reset,
            Enable  => global_enable,
            ClkEn   => clk_enable,

            -- Handshaking Protocol
            ready_for_updates => ready_for_updates,  -- From main to shim for gating updates

            -- Friendly Application Signals
{% for reg in registers %}
            {{ reg.friendly_name }} => {{ reg.friendly_name }},
{% endfor %}

            -- BRAM Interface (always exposed for consistency)
            bram_addr => bram_addr,
            bram_data => bram_data,
            bram_we   => bram_we,

            -- MCC I/O
            InputA  => InputA,
            InputB  => InputB,{% if num_inputs >= 3 %}
            InputC  => InputC,{% endif %}{% if num_inputs >= 4 %}
            InputD  => InputD,{% endif %}
            OutputA => OutputA,
            OutputB => OutputB{% if num_outputs >= 3 %},
            OutputC => OutputC{% endif %}{% if num_outputs >= 4 %},
            OutputD => OutputD{% endif %}
        );

end architecture rtl;
