# Package Integration Guide

**Date**: 2025-01-28
**Status**: Reference documentation
**Audience**: Developers working with EZ-EMFI VHDL packages

## Overview

This guide explains how to use the three percentage/voltage conversion packages in the EZ-EMFI project:

1. **`volo_voltage_pkg.vhd`** - Base voltage conversion (always needed)
2. **`Moku_Pct_pkg.vhd`** - Simple linear percentage-to-voltage (from EXTERNAL_volo_vhdl)
3. **`volo_lut_pkg.vhd`** - Complex non-linear lookup tables (new)

## Quick Decision Tree

```
Need percentage-based control?
│
├─ YES: Is the mapping linear?
│   │
│   ├─ YES: Use Moku_Pct_pkg
│   │   └─ Example: 50% = 2.5V on 0-5V scale
│   │
│   └─ NO: Is it a simple formula (e.g., x^2, sqrt(x))?
│       │
│       ├─ YES: Write custom function
│       │   └─ Example: quadratic_scale(pct) = (pct^2) * max_value / 10000
│       │
│       └─ NO: Use volo_lut_pkg
│           └─ Example: Gamma curves, calibration tables, empirical data
│
└─ NO: Use volo_voltage_pkg directly
    └─ Example: voltage_to_digital(2.5) → signed(15 downto 0)
```

## Package Comparison Table

| Feature | volo_voltage_pkg | Moku_Pct_pkg | volo_lut_pkg |
|---------|------------------|--------------|--------------|
| **Purpose** | Voltage ↔ digital conversion | Linear pct → voltage | Non-linear LUTs |
| **Input** | Voltage (real) | Percentage (0-100) | Index (0-100) |
| **Output** | signed(15:0) | signed(15:0) | std_logic_vector/signed |
| **Memory** | Zero | Zero (pure functions) | 202 bytes per LUT |
| **Overhead** | Minimal | Minimal | Constant ROM |
| **Flexibility** | Exact voltages | Fixed ranges | Arbitrary curves |
| **When to use** | Always (base layer) | Simple linear control | Complex mappings |

## Usage Examples

### Example 1: Simple Linear Intensity Control

**Requirement**: User sets intensity 0-100%, maps to 0-3.0V output.

**Solution**: Use `Moku_Pct_pkg`

```vhdl
use work.Moku_Voltage_pkg.all;
use work.Moku_Pct_pkg.all;

signal user_intensity : pct_3v3_t := 75;  -- 75% = 2.475V
signal output_voltage : signed(15 downto 0);

-- Direct conversion (zero memory overhead)
output_voltage <= pct_3v3_to_digital(user_intensity);
```

**Why this choice?**
- Linear mapping (75% = 75% of 3.3V)
- Zero memory overhead
- Type-safe percentage types

### Example 2: LED Brightness with Gamma Correction

**Requirement**: User sets brightness 0-100%, but human perception is non-linear (gamma = 2.2).

**Solution**: Use `volo_lut_pkg`

```vhdl
use work.volo_lut_pkg.all;

-- Pre-computed gamma curve (generated by Python script)
constant LED_GAMMA_22 : lut_101x16_t := (
    16#0000#, 16#0001#, 16#0004#, 16#0009#, 16#0010#,  -- 0-4%
    16#0019#, 16#0024#, 16#0031#, 16#0040#, 16#0051#,  -- 5-9%
    -- ... (see Python generation script in VOLO_LUT_PKG_DESIGN.md)
    16#7FFF#  -- 100%
);

signal user_brightness : pct_index_t := 50;  -- 50% perceived brightness
signal pwm_value : unsigned(15 downto 0);

-- Non-linear lookup
pwm_value <= unsigned(lut_lookup(LED_GAMMA_22, user_brightness));
```

**Why this choice?**
- Non-linear (gamma 2.2 curve)
- Pre-computed for fast lookup
- Human perception requires specific curve

### Example 3: Temperature Compensation

**Requirement**: Voltage offset varies with temperature (empirical calibration data).

**Solution**: Use `volo_lut_pkg`

```vhdl
use work.volo_lut_pkg.all;

-- Empirical temperature compensation (from lab measurements)
-- Index: 0 = 0°C, 100 = 100°C
constant TEMP_COMP_LUT : lut_101x16_signed_t := (
    to_signed(-1500, 16),  -- 0°C: -1.5V offset (using mV * 1000 scale)
    to_signed(-1480, 16),  -- 1°C
    -- ... (from calibration procedure)
    to_signed(0, 16),      -- 50°C: no offset
    -- ...
    to_signed(+1500, 16)   -- 100°C: +1.5V offset
);

signal temperature_pct : pct_index_t;  -- ADC → 0-100 mapping
signal voltage_offset : signed(15 downto 0);

voltage_offset <= lut_lookup_signed(TEMP_COMP_LUT, temperature_pct);
```

**Why this choice?**
- Empirical data (no simple formula)
- Non-linear relationship
- Lookup faster than polynomial approximation

### Example 4: Hybrid Approach

**Requirement**: Coarse adjustment (linear) + fine trim (non-linear calibration).

**Solution**: Combine `Moku_Pct_pkg` + `volo_lut_pkg`

```vhdl
use work.Moku_Pct_pkg.all;
use work.volo_lut_pkg.all;

-- Coarse adjustment (linear)
signal coarse_setting : pct_5v0_t := 80;  -- 80% of 5V = 4.0V
signal coarse_voltage : signed(15 downto 0);

coarse_voltage <= pct_5v0_to_digital(coarse_setting);

-- Fine trim (calibration LUT)
signal trim_index : pct_index_t;
signal trim_offset : signed(15 downto 0);

trim_offset <= lut_lookup_signed(CALIBRATION_LUT, trim_index);

-- Combined output
signal final_voltage : signed(15 downto 0);
final_voltage <= coarse_voltage + trim_offset;
```

**Why this choice?**
- Leverages strengths of both packages
- Linear coarse control (user-friendly)
- Non-linear fine trim (accuracy)

## Integration Patterns

### Pattern 1: Direct Replacement

When migrating from manual voltage calculations to percentage-based:

**Before**:
```vhdl
-- Manual voltage calculation
constant PROBE_VOLTAGE : signed(15 downto 0) := to_signed(19661, 16);  -- 3.0V
```

**After**:
```vhdl
use work.Moku_Pct_pkg.all;

-- Percentage-based (more readable)
signal probe_intensity : pct_5v0_t := 60;  -- 60% of 5V = 3.0V
signal probe_voltage : signed(15 downto 0);

probe_voltage <= pct_5v0_to_digital(probe_intensity);
```

### Pattern 2: User Control Interface

Register-based percentage control:

```vhdl
use work.Moku_Pct_pkg.all;

-- Control register mapping (7 bits for 0-100)
signal intensity_reg : std_logic_vector(6 downto 0);  -- From MCC Control0[6:0]
signal intensity_pct : pct_3v3_t;
signal output_voltage : signed(15 downto 0);

-- Convert register to percentage (with clamping)
process(Clk, Reset)
begin
    if Reset = '1' then
        intensity_pct <= 0;
    elsif rising_edge(Clk) then
        -- Clamp to 0-100 range
        if to_integer(unsigned(intensity_reg)) > 100 then
            intensity_pct <= 100;
        else
            intensity_pct <= to_integer(unsigned(intensity_reg));
        end if;
    end if;
end process;

-- Convert to voltage
output_voltage <= pct_3v3_to_digital(intensity_pct);
```

### Pattern 3: LUT Generation Workflow

Python → VHDL constant workflow:

```python
#!/usr/bin/env python3
# generate_lut.py

import numpy as np

def generate_gamma_curve(gamma=2.2, max_value=32767):
    indices = np.arange(101)
    normalized = indices / 100.0
    corrected = np.power(normalized, gamma)
    return (corrected * max_value).astype(int)

def format_vhdl_lut(values, name="MY_LUT"):
    lines = [f"constant {name} : lut_101x16_t := ("]
    for i in range(0, len(values), 5):
        chunk = values[i:i+5]
        hex_vals = ", ".join(f"16#{v:04X}#" for v in chunk)
        lines.append(f"    {hex_vals},")
    lines.append(");")
    return "\n".join(lines)

# Generate and print
lut = generate_gamma_curve(gamma=2.2)
print(format_vhdl_lut(lut, "LED_GAMMA_22"))
```

Usage:
```bash
python generate_lut.py > my_luts.vhd
# Then copy constant into your VHDL file
```

## Package Organization

After migration (see `VHDL_PACKAGE_MIGRATION.md`):

```
VHDL/packages/
├── volo_voltage_pkg.vhd       # Base layer (voltage ↔ digital)
├── ds1120_pd_pkg.vhd          # Application-specific constants
├── volo_common_pkg.vhd        # Shared infrastructure
└── volo_lut_pkg.vhd           # LUT infrastructure (new)

EXTERNAL_volo_vhdl/modules/shared/packages/
└── Moku_Pct_pkg.vhd           # Linear percentage conversion
```

**Dependency chain**:
```
Your module
    ├── depends on volo_lut_pkg (if using LUTs)
    │   └── depends on volo_voltage_pkg
    │
    ├── depends on Moku_Pct_pkg (if using linear %)
    │   └── depends on volo_voltage_pkg (from EXTERNAL)
    │
    └── depends on volo_voltage_pkg (always)
```

## Testing Strategy

### Unit Testing Pattern

Test each package independently:

```python
# tests/test_volo_lut_pkg.py

import cocotb
from cocotb.triggers import Timer

@cocotb.test()
async def test_lut_bounds(dut):
    """Test bounds checking with saturation"""
    # Index 0 → LUT[0]
    dut.index.value = 0
    await Timer(1, units='ns')
    assert dut.output.value == dut.lut[0]

    # Index 100 → LUT[100]
    dut.index.value = 100
    await Timer(1, units='ns')
    assert dut.output.value == dut.lut[100]

    # Index 150 → LUT[100] (saturated)
    dut.index.value = 150
    await Timer(1, units='ns')
    assert dut.output.value == dut.lut[100]
```

### Integration Testing Pattern

Test combined usage:

```python
@cocotb.test()
async def test_linear_vs_lut(dut):
    """Compare linear Moku_Pct_pkg vs LUT approach"""

    # Test that linear LUT matches Moku_Pct_pkg
    for pct in range(0, 101, 10):
        dut.pct_input.value = pct

        # Get linear result (Moku_Pct_pkg)
        dut.use_moku_pct.value = 1
        await Timer(1, units='ns')
        linear_result = dut.output.value

        # Get LUT result (volo_lut_pkg with LINEAR_5V_LUT)
        dut.use_moku_pct.value = 0
        await Timer(1, units='ns')
        lut_result = dut.output.value

        # Should match (both are linear)
        assert linear_result == lut_result
```

## Common Pitfalls

### Pitfall 1: Type Confusion

**Problem**: Mixing pct types from different packages

```vhdl
-- ✗ WRONG: These are NOT type-safe!
signal level_a : pct_5v0_t := 50;   -- From Moku_Pct_pkg
signal level_b : pct_index_t := 75; -- From volo_lut_pkg

level_a <= level_b;  -- Compiles but semantically wrong!
```

**Solution**: Be explicit about conversions

```vhdl
-- ✓ CORRECT: Explicit conversion with comment
signal level_a : pct_5v0_t := 50;
signal level_b : pct_index_t := 75;

-- Intentional cross-package conversion (documented)
level_a <= pct_5v0_t(level_b);  -- Explicit cast
```

### Pitfall 2: LUT Memory Overhead

**Problem**: Creating too many large LUTs

```vhdl
-- ✗ WRONG: Excessive memory usage
constant LUT_1 : lut_101x16_t := (...);  -- 202 bytes
constant LUT_2 : lut_101x16_t := (...);  -- 202 bytes
constant LUT_3 : lut_101x16_t := (...);  -- 202 bytes
-- ... 10 more LUTs = 2.6 KB total!
```

**Solution**: Use linear functions where possible

```vhdl
-- ✓ BETTER: Use Moku_Pct_pkg for linear cases
signal linear_voltage : signed(15 downto 0);
linear_voltage <= pct_5v0_to_digital(user_pct);  -- Zero memory

-- Only use LUTs for non-linear
constant GAMMA_LUT : lut_101x16_t := (...);  -- 202 bytes (justified)
```

### Pitfall 3: Ignoring Bounds Checking

**Problem**: Assuming indices are always valid

```vhdl
-- ✗ RISKY: Direct array access
signal unsafe_index : natural := 150;  -- Oops!
output <= MY_LUT(unsafe_index);  -- Runtime error!
```

**Solution**: Use provided lookup functions

```vhdl
-- ✓ SAFE: Automatic saturation
signal user_index : natural := 150;
output <= lut_lookup(MY_LUT, user_index);  -- Returns MY_LUT(100)
```

## Migration Checklist

When adding percentage control to existing module:

- [ ] Identify control type: linear or non-linear?
- [ ] Choose package: `Moku_Pct_pkg` or `volo_lut_pkg`?
- [ ] Add `use work.<package>.all;` to VHDL file
- [ ] Update test_configs.py with package dependency
- [ ] Replace magic numbers with percentage types
- [ ] Add unit tests for conversion functions
- [ ] Add integration tests for full chain
- [ ] Document choice in module header comments
- [ ] Update MCC register mapping (if applicable)
- [ ] Test on hardware (if available)

## Best Practices

1. **Start simple**: Try `Moku_Pct_pkg` first, only use LUTs if needed
2. **Document rationale**: Comment WHY you chose LUT vs linear
3. **Use Python generation**: Don't hand-code large LUTs
4. **Test bounds**: Always test index 0, 100, and >100
5. **Memory budget**: Track total LUT usage across module
6. **Naming**: Use descriptive LUT names (e.g., `LED_GAMMA_22` not `LUT1`)
7. **Version control**: Check in Python LUT generators, not just constants

## Resources

- **`VHDL_PACKAGE_MIGRATION.md`** - How to reorganize packages
- **`VOLO_LUT_PKG_DESIGN.md`** - Deep dive on LUT design
- **`volo_lut_pkg.vhd`** - Implementation reference
- **`Moku_Pct_pkg.vhd`** - Located in `EXTERNAL_volo_vhdl/modules/shared/packages/`

## Summary

**Three-tier approach**:
1. **volo_voltage_pkg** - Foundation (always needed)
2. **Moku_Pct_pkg** - Simple linear control (try first)
3. **volo_lut_pkg** - Complex curves (when needed)

**Decision process**:
- Linear? → Moku_Pct_pkg (zero overhead)
- Simple formula? → Custom function
- Complex/empirical? → volo_lut_pkg

**Key principle**: **Use the simplest tool that solves the problem.**

---

**Author**: Claude Code
**Date**: 2025-01-28
**Status**: Reference guide
