# volo_lut_pkg Design Document

**Date**: 2025-01-28
**Status**: DRAFT - Design specification
**Location**: `VHDL/packages/volo_lut_pkg.vhd`

## Purpose

Provide generic 0-100 indexed lookup table (LUT) infrastructure for non-linear voltage mappings, calibration curves, and complex waveform generation on Moku platform.

## Design Philosophy

### What This Package IS

**Generic LUT Infrastructure** for complex mappings:
- Gamma correction curves
- Non-linear calibration tables
- Pre-computed waveforms
- Temperature compensation curves
- Custom transfer functions

**Key Features**:
- Human-friendly 0-100 indexing (percentage-based)
- 7-bit index type (perfect fit for hardware)
- Runtime bounds checking with saturation
- Verilog-portable design
- Integration with `volo_voltage_pkg`

### What This Package IS NOT

**NOT a replacement for `Moku_Pct_pkg`**:
- Simple linear conversions stay in `Moku_Pct_pkg` (function-based)
- This package is for COMPLEX/NON-LINEAR data only

**NOT a database**:
- No CRC validation (removed from archived `PercentLut_pkg`)
- No record structures in RTL interfaces
- No runtime LUT modification (constants only)

## Use Cases

### Use Case 1: Gamma Correction for LED Brightness

```vhdl
use work.volo_lut_pkg.all;

-- Perceptually linear brightness curve (gamma = 2.2)
constant LED_GAMMA_CURVE : lut_101x16_t := (
    16#0000#, 16#0001#, 16#0004#, 16#0009#, 16#0010#,  -- 0-4%
    16#0019#, 16#0024#, 16#0031#, 16#0040#, 16#0051#,  -- 5-9%
    -- ... generated by Python script
    16#7FFF#  -- 100%
);

signal user_brightness : pct_index_t := 50;  -- 50% perceived brightness
signal led_pwm_value : unsigned(15 downto 0);

led_pwm_value <= unsigned(lut_lookup(LED_GAMMA_CURVE, user_brightness));
```

### Use Case 2: Temperature Compensation

```vhdl
-- Voltage adjustment for temperature drift
constant TEMP_COMPENSATION_LUT : lut_101x16_signed_t := (
    to_signed(-1500, 16),  -- 0°C: -1.5V offset
    to_signed(-1450, 16),  -- 1°C
    -- ...
    to_signed(0, 16),      -- 50°C: no offset
    -- ...
    to_signed(+1500, 16)   -- 100°C: +1.5V offset
);

signal temp_pct : pct_index_t;  -- 0-100 = 0-100°C
signal voltage_offset : signed(15 downto 0);

voltage_offset <= lut_lookup_signed(TEMP_COMPENSATION_LUT, temp_pct);
```

### Use Case 3: Custom Waveform Generation

```vhdl
-- Pre-computed waveform segment
constant WAVEFORM_SEGMENT : lut_101x16_t := (
    -- Generated by Python DSP tooling
    16#0000#, 16#0CCC#, 16#18F8#, 16#2410#, ...
);

signal phase_index : pct_index_t;
signal waveform_out : signed(15 downto 0);

-- Phase accumulator maps to 0-100 index
phase_index <= to_pct_index(phase_accumulator(15 downto 9));  -- 7-bit → pct_index_t
waveform_out <= signed(lut_lookup(WAVEFORM_SEGMENT, phase_index));
```

## Type System

### Core Types

```vhdl
-- Percentage index (0-100) - 7-bit natural
subtype pct_index_t is natural range 0 to 100;

-- Standard unsigned LUT (101 entries × 16-bit)
type lut_101x16_t is array (0 to 100) of std_logic_vector(15 downto 0);

-- Signed LUT variant (for bipolar data)
type lut_101x16_signed_t is array (0 to 100) of signed(15 downto 0);
```

**Why these types?**
- `pct_index_t`: Documents intent, provides runtime range checking
- `lut_101x16_t`: Standard Moku digital code width (16-bit)
- `lut_101x16_signed_t`: Bipolar voltages, offsets, corrections

### Type Safety Philosophy

**Subtypes for documentation, functions for safety**:

```vhdl
-- Subtype provides naming clarity but NO compile-time type checking
subtype pct_index_t is natural range 0 to 100;

-- Function provides runtime boundary enforcement
function lut_lookup(lut : lut_101x16_t; idx : pct_index_t) return std_logic_vector is
begin
    -- Clamp to valid range (saturation)
    if idx > 100 then
        return lut(100);
    else
        return lut(idx);
    end if;
end function;
```

**Why not distinct types?**
- VHDL distinct types break arithmetic: `idx + 1` requires `pct_index_t(natural(idx) + 1)`
- Subtypes + function boundaries = pragmatic safety

## Function Interface

### Core Lookup Functions

```vhdl
-- Unsigned LUT lookup with bounds checking
function lut_lookup(
    lut : lut_101x16_t;
    idx : pct_index_t
) return std_logic_vector;

-- Signed LUT lookup with bounds checking
function lut_lookup_signed(
    lut : lut_101x16_signed_t;
    idx : pct_index_t
) return signed;

-- Natural index variant (convenience)
function lut_lookup(
    lut : lut_101x16_t;
    idx : natural
) return std_logic_vector;
```

### Utility Functions

```vhdl
-- Convert std_logic_vector to pct_index_t (clamping)
function to_pct_index(slv : std_logic_vector) return pct_index_t;

-- Convert natural to pct_index_t (clamping)
function to_pct_index(n : natural) return pct_index_t;

-- Validate index (0-100 check)
function is_valid_pct_index(idx : natural) return boolean;
```

### Voltage Integration Functions

```vhdl
-- Create LUT from voltage range (linear interpolation)
function create_linear_voltage_lut(
    min_voltage : real;
    max_voltage : real
) return lut_101x16_signed_t;

-- Map voltage to LUT index (0-100)
function voltage_to_pct_index(
    voltage : real;
    min_voltage : real;
    max_voltage : real
) return pct_index_t;
```

## Verilog Portability Strategy

### Arrays → Parameter Arrays

```vhdl
-- VHDL
constant MY_LUT : lut_101x16_t := (...);
```

```verilog
// Verilog
parameter [15:0] MY_LUT [0:100] = '{
    16'h0000, 16'h0001, ...
};
```

### Functions → Verilog Functions

```vhdl
-- VHDL
output <= lut_lookup(MY_LUT, index);
```

```verilog
// Verilog
function [15:0] lut_lookup;
    input [15:0] lut [0:100];
    input [6:0] idx;
    begin
        if (idx > 100)
            lut_lookup = lut[100];
        else
            lut_lookup = lut[idx];
    end
endfunction

assign output = lut_lookup(MY_LUT, index);
```

### No Records in Ports

**Allowed**:
```vhdl
signal my_lut : lut_101x16_t;  -- Internal signal
constant GAMMA : lut_101x16_t := (...);  -- Constant
```

**Forbidden**:
```vhdl
entity foo is
    port (
        lut_in : in lut_101x16_t  -- ✗ Array port (Verilog nightmare)
    );
end entity;
```

**Solution**: Use individual array elements or flattened vectors if needed.

## Integration with volo_voltage_pkg

### Dependency

```vhdl
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Import voltage conversion utilities
use work.volo_voltage_pkg.all;

package volo_lut_pkg is
    -- LUT types and functions
end package;
```

### Helper Functions

```vhdl
-- Create linear voltage LUT (uses voltage_to_digital from volo_voltage_pkg)
function create_linear_voltage_lut(
    min_voltage : real;
    max_voltage : real
) return lut_101x16_signed_t is
    variable result : lut_101x16_signed_t;
    variable voltage : real;
begin
    for i in 0 to 100 loop
        voltage := min_voltage + (real(i) / 100.0) * (max_voltage - min_voltage);
        result(i) := voltage_to_digital(voltage);  -- From volo_voltage_pkg
    end loop;
    return result;
end function;
```

## Example: Python LUT Generation

```python
#!/usr/bin/env python3
"""Generate VHDL LUT constants from Python"""

import numpy as np

def generate_gamma_lut(gamma=2.2, max_value=32767):
    """Generate gamma correction LUT for LED brightness"""
    indices = np.arange(101)
    normalized = indices / 100.0
    gamma_corrected = np.power(normalized, gamma)
    digital_values = (gamma_corrected * max_value).astype(int)
    return digital_values

def format_vhdl_lut(values, name="GAMMA_CURVE"):
    """Format LUT values as VHDL constant"""
    lines = [f"constant {name} : lut_101x16_t := ("]

    for i in range(0, len(values), 5):
        chunk = values[i:i+5]
        hex_values = ", ".join(f"16#{v:04X}#" for v in chunk)
        comment = f"-- {i:3d}-{min(i+4, 100):3d}%"
        lines.append(f"    {hex_values},  {comment}")

    lines.append(");")
    return "\n".join(lines)

# Usage
lut_values = generate_gamma_lut(gamma=2.2)
print(format_vhdl_lut(lut_values, "LED_GAMMA_22"))
```

Output:
```vhdl
constant LED_GAMMA_22 : lut_101x16_t := (
    16#0000#, 16#0001#, 16#0004#, 16#0009#, 16#0010#,  --   0-  4%
    16#0019#, 16#0024#, 16#0031#, 16#0040#, 16#0051#,  --   5-  9%
    ...
    16#7B5E#, 16#7D0F#, 16#7EC1#, 16#8000#,            --  96-100%
);
```

## Comparison with Moku_Pct_pkg

| Feature | Moku_Pct_pkg | volo_lut_pkg |
|---------|--------------|--------------|
| **Purpose** | Linear percentage-to-voltage conversion | Non-linear lookup tables |
| **Implementation** | Pure functions (no memory) | Constant arrays |
| **Overhead** | Zero (computed at synthesis) | 101 × 16-bit × N_LUTs |
| **Flexibility** | Linear only | Arbitrary curves |
| **Use Case** | Simple mappings (50% = 2.5V) | Gamma curves, calibration |
| **When to use** | Always try this FIRST | When linear doesn't work |

**Decision Tree**:
1. **Is mapping linear?** → Use `Moku_Pct_pkg` (zero overhead)
2. **Is mapping non-linear but simple formula?** → Use custom function (e.g., `x^2`)
3. **Is mapping complex/empirical?** → Use `volo_lut_pkg`

## Testing Strategy

### Unit Tests (CocotB)

```python
@cocotb.test()
async def test_lut_bounds_checking(dut):
    """Test that out-of-range indices are clamped"""
    # Test index > 100 saturates to LUT[100]
    assert lookup(lut, 150) == lut[100]

    # Test index = 0 works
    assert lookup(lut, 0) == lut[0]

    # Test index = 100 works
    assert lookup(lut, 100) == lut[100]
```

### Integration Tests

Test with real use cases:
- Gamma curve applied to LED PWM
- Temperature compensation in closed-loop system
- Waveform generation with phase accumulator

## File Organization

```
VHDL/packages/
├── volo_voltage_pkg.vhd      # Base voltage utilities
├── volo_lut_pkg.vhd           # LUT infrastructure (NEW)
└── Moku_Pct_pkg.vhd           # Linear percentage conversions (EXTERNAL)
```

**Dependencies**:
- `volo_lut_pkg` depends on `volo_voltage_pkg`
- `volo_lut_pkg` does NOT depend on `Moku_Pct_pkg` (different concerns)

## Implementation Notes

### Memory Overhead

Each LUT costs **101 × 16-bit = 202 bytes** in FPGA block RAM.

**Optimization strategies**:
1. **Share LUTs** across multiple instances if possible
2. **Use smaller LUTs** if resolution allows (e.g., 50-entry LUT)
3. **Compress sparse LUTs** using piecewise linear interpolation

### Synthesis Considerations

- All LUTs should be `constant` (synthesize to ROM/BRAM)
- Avoid `variable` LUTs (would require RAM with write logic)
- GHDL will elaborate constants at compile time

### Naming Conventions

- **LUT constants**: `ALL_CAPS_WITH_UNDERSCORES`
- **Example**: `LED_GAMMA_22`, `TEMP_COMPENSATION_0_100C`
- **Include units/range in name**: `WAVEFORM_0_TO_5V`, `GAIN_CORRECTION_DB`

## Future Extensions

### Potential Additions (Not in v1.0)

1. **Interpolation functions** - Linear interpolation between LUT points
2. **2D LUTs** - For complex mappings (e.g., voltage vs temperature)
3. **Compressed LUTs** - Store fewer points, interpolate between
4. **Dual-port LUT access** - For parallel lookups

### Out of Scope

- Runtime LUT modification (use BRAM loader for that)
- CRC validation (unnecessary overhead for constants)
- Record-based structures (Verilog portability)

## Summary

**volo_lut_pkg** provides:
- ✓ Human-friendly 0-100 indexing
- ✓ Generic infrastructure for complex mappings
- ✓ Runtime bounds checking with saturation
- ✓ Verilog portability
- ✓ Integration with `volo_voltage_pkg`
- ✓ Zero overhead for unused features (constants optimized away)

**When to use**:
- Non-linear voltage curves
- Calibration tables
- Pre-computed waveforms
- Any 0-100 indexed data structure

**When NOT to use**:
- Linear percentage conversions (use `Moku_Pct_pkg`)
- Simple formulas (use custom functions)
- Dynamic lookup tables (use BRAM infrastructure)

---

**Next Step**: Implement `volo_lut_pkg.vhd` based on this design
